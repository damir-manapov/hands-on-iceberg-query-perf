/**
 * query.ts ‚Äî Run performance tests on count queries with sample filters
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { TrinoClient } from "../TrinoClient";
import { TABLE_CONFIG } from "../config/tableConfig";
import { createTrinoConfig } from "../config/trinoConfig";
import { createQueryDefinitions } from "../config/queries";

interface QueryResult {
  query: string;
  duration: number;
  count: number;
}

interface QueryStats {
  query: string;
  description: string;
  count: number;
  avgDuration: number;
  minDuration: number;
  maxDuration: number;
  p95Duration: number;
  runs: number;
}

interface TableMetadata {
  totalRows: number;
  totalSizeBytes: number;
  totalSizeHuman: string;
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return "0 B";
  const thresh = 1024;
  const units = ["B", "KB", "MB", "GB", "TB", "PB"];
  let u = 0;
  let b = bytes;
  while (b >= thresh && u < units.length - 1) {
    b /= thresh;
    u++;
  }
  return `${b.toFixed(1)} ${units[u]}`;
}

function calculatePercentile(values: number[], percentile: number): number {
  if (values.length === 0) return 0;
  if (values.length === 1) return values[0];
  
  const sorted = [...values].sort((a, b) => a - b);
  const index = (percentile / 100) * (sorted.length - 1);
  
  if (Number.isInteger(index)) {
    return sorted[index];
  } else {
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    const weight = index - lower;
    return sorted[lower] * (1 - weight) + sorted[upper] * weight;
  }
}

async function getTableMetadata(client: TrinoClient, tableName: string): Promise<TableMetadata> {
  // Get total row count
  const countResult = await client.query<{ count: number }>(`SELECT COUNT(*) as count FROM ${tableName}`);
  const totalRows = countResult[0]?.count ?? 0;
  
  // Get table size from files metadata
  const filesTable = `"${tableName.split('.').pop()}$files"`;
  const sizeResult = await client.query<{ total_bytes: number }>(
    `SELECT SUM(file_size_in_bytes) as total_bytes FROM ${tableName.split('.')[0]}.${tableName.split('.')[1]}.${filesTable}`
  );
  const totalSizeBytes = sizeResult[0]?.total_bytes ?? 0;
  
  return {
    totalRows,
    totalSizeBytes,
    totalSizeHuman: formatBytes(totalSizeBytes)
  };
}

function generateMarkdownReport(
  tableName: string,
  tableMetadata: TableMetadata,
  queryStats: QueryStats[],
  overallStats: { totalQueries: number; avgDuration: number; minDuration: number; maxDuration: number; p95Duration: number },
  timestamp: string
): string {
  const report = `# Query Performance Report

**Table:** ${tableName}  
**Total Rows:** ${tableMetadata.totalRows.toLocaleString()}  
**Table Size:** ${tableMetadata.totalSizeHuman} (${tableMetadata.totalSizeBytes.toLocaleString()} bytes)  
**Generated:** ${timestamp}  
**Total Queries Run:** ${overallStats.totalQueries}

## Summary

- **Average Duration:** ${overallStats.avgDuration.toFixed(1)}ms
- **Fastest Query:** ${overallStats.minDuration}ms
- **Slowest Query:** ${overallStats.maxDuration}ms
- **95th Percentile:** ${overallStats.p95Duration.toFixed(1)}ms

## Query Results

| Description | Count | Avg Duration (ms) | Min Duration (ms) | Max Duration (ms) | P95 Duration (ms) | Runs |
|-------------|-------|-------------------|-------------------|-------------------|-------------------|------|
${queryStats.map(stats => 
  `| ${stats.description} | ${stats.count.toLocaleString()} | ${stats.avgDuration.toFixed(1)} | ${stats.minDuration} | ${stats.maxDuration} | ${stats.p95Duration.toFixed(1)} | ${stats.runs} |`
).join('\n')}

## Query Details

${queryStats.map(stats => 
  `### ${stats.description}

\`\`\`sql
${stats.query}
\`\`\`

- **Count:** ${stats.count.toLocaleString()}
- **Average Duration:** ${stats.avgDuration.toFixed(1)}ms
- **Min Duration:** ${stats.minDuration}ms
- **Max Duration:** ${stats.maxDuration}ms
- **95th Percentile:** ${stats.p95Duration.toFixed(1)}ms
- **Runs:** ${stats.runs}

---
`
).join('\n')}

*Report generated by hands-on-iceberg-query-perf*
`;

  return report;
}

async function runQuery(
  client: TrinoClient,
  sql: string,
  description: string
): Promise<QueryResult> {
  console.log(`\nüîç ${description}`);
  console.log(`SQL: ${sql}`);
  
  const startTime = Date.now();
  
  // Handle different query types
  if (sql.includes('COUNT(*)')) {
    const result = await client.query<{ count: number }>(sql);
    const duration = Date.now() - startTime;
    const count = result[0]?.count ?? 0;
    console.log(`‚úÖ Count: ${count.toLocaleString()}, Duration: ${duration}ms`);
    return { query: sql, duration, count };
  } else {
    // For debug queries, just execute and show results
    const result = await client.query(sql);
    const duration = Date.now() - startTime;
    console.log(`‚úÖ Result:`, result);
    console.log(`Duration: ${duration}ms`);
    // Return count as 0 for non-count queries
    return { query: sql, duration, count: 0 };
  }
}

async function main() {
  // Trino connection
  const trino = createTrinoConfig("query");
  const client = new TrinoClient(trino);
  
  const tableName = TABLE_CONFIG.tableBase;
  const fullTableName = `${TABLE_CONFIG.catalog}.${TABLE_CONFIG.schema}.${tableName}`;
  
  console.log(`üöÄ Running query performance tests on ${fullTableName}`);
  
  // Get table metadata first
  console.log("üìä Gathering table metadata...");
  const tableMetadata = await getTableMetadata(client, fullTableName);
  console.log(`üìà Table has ${tableMetadata.totalRows.toLocaleString()} rows (${tableMetadata.totalSizeHuman})`);
  
  // Check if table has data
  if (tableMetadata.totalRows === 0) {
    console.log("‚ö†Ô∏è  WARNING: Table has no data! Run 'yarn load' first to generate data.");
    return;
  }
  
  // Test queries with different filters
  const queries = createQueryDefinitions(fullTableName);
  
  const results: QueryResult[] = [];
  const iterations = 3; // Run each query multiple times
  
  for (const { sql, description } of queries) {
    console.log(`\nüìä Running "${description}" ${iterations} times...`);
    
    for (let i = 1; i <= iterations; i++) {
      const result = await runQuery(client, sql, `${description} (run ${i}/${iterations})`);
      results.push(result);
      
      // Small delay between runs
      if (i < iterations) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  }
  
  // Calculate and display statistics
  console.log("\nüìà PERFORMANCE SUMMARY");
  console.log("=" .repeat(80));
  
  const queryGroups = new Map<string, QueryResult[]>();
  for (const result of results) {
    const key = result.query;
    if (!queryGroups.has(key)) {
      queryGroups.set(key, []);
    }
    queryGroups.get(key)!.push(result);
  }
  
  for (const [query, runs] of queryGroups) {
    const durations = runs.map(r => r.duration);
    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const minDuration = Math.min(...durations);
    const maxDuration = Math.max(...durations);
    const p95Duration = calculatePercentile(durations, 95);
    const count = runs[0].count; // All runs should have same count
    
    console.log(`\nQuery: ${query}`);
    console.log(`Count: ${count.toLocaleString()}`);
    console.log(`Duration: avg=${avgDuration.toFixed(1)}ms, min=${minDuration}ms, max=${maxDuration}ms, p95=${p95Duration.toFixed(1)}ms`);
  }
  
  // Overall statistics
  const allDurations = results.map(r => r.duration);
  const overallAvg = allDurations.reduce((a, b) => a + b, 0) / allDurations.length;
  const overallMin = Math.min(...allDurations);
  const overallMax = Math.max(...allDurations);
  const overallP95 = calculatePercentile(allDurations, 95);
  
  console.log(`\nüéØ OVERALL STATISTICS`);
  console.log(`Total queries run: ${results.length}`);
  console.log(`Average duration: ${overallAvg.toFixed(1)}ms`);
  console.log(`Fastest query: ${overallMin}ms`);
  console.log(`Slowest query: ${overallMax}ms`);
  console.log(`95th percentile: ${overallP95.toFixed(1)}ms`);
  
  // Generate markdown report
  const timestamp = new Date().toISOString();
  const queryStats: QueryStats[] = [];
  
  for (const [query, runs] of queryGroups) {
    const durations = runs.map(r => r.duration);
    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const minDuration = Math.min(...durations);
    const maxDuration = Math.max(...durations);
    const p95Duration = calculatePercentile(durations, 95);
    const count = runs[0].count;
    
    // Find description for this query
    const queryDef = queries.find(q => q.sql === query);
    const description = queryDef?.description || "Unknown query";
    
    queryStats.push({
      query,
      description,
      count,
      avgDuration,
      minDuration,
      maxDuration,
      p95Duration,
      runs: runs.length
    });
  }
  
  const overallStats = {
    totalQueries: results.length,
    avgDuration: overallAvg,
    minDuration: overallMin,
    maxDuration: overallMax,
    p95Duration: overallP95
  };
  
  const markdownReport = generateMarkdownReport(fullTableName, tableMetadata, queryStats, overallStats, timestamp);
  
  // Write report to file
  const reportDir = "reports";
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  
  const reportFile = path.join(reportDir, "query-performance.md");
  fs.writeFileSync(reportFile, markdownReport, "utf-8");
  
  console.log(`\nüìÑ Markdown report saved to: ${reportFile}`);
}

main().catch(e => {
  console.error(e);
  process.exit(1);
});
